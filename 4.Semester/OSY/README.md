# OSY - Operating Systems

## SYNOPSIS
In this course that is a follow-up of the Unix-like operating systems course students deepen their knowledge in areas of OS kernels, process and thread implementations, race conditions, critical regions, thread scheduling, shared resource allocation and deadlocks, management of virtual memory and data storages, file systems, OS monitoring. They are able to design and implement simple multithreaded applications. General principles are illustrated on operating systems Solaris, Linux, or MS Windows.

## COURSE CONTENTS
In this course that is a follow-up of the Unix-like operating systems course students deepen their knowledge in areas of OS kernels, process and thread implementations, race conditions, critical regions, thread scheduling, shared resource allocation and deadlocks, management of virtual memory and data storages, file systems, OS monitoring. They are able to design and implement simple multithreaded applications. General principles are illustrated on operating systems Solaris, Linux, or MS Windows.

## GOALS OF STUDY
The course is an introduction into the classical operating system theory. The aim is to get students acquainted with the fundamental theory and concepts of operating systems and apply this theoretical knowledge for operating system administration. After completing the course, students will be able to design and implement multithreaded applications.

## LECTURES SYLLABUS
1. Introduction, OS architecture and functionalities, taxonomy of computing systems.
2. Processes and threads. Thread scheduling, context switching, thread states. Race conditions.
3. Thread synchronization - critical regions, busy waiting, mutexes, semaphores, conditional variables, synchronization producer-consumer problem, barriers.
4. Classical synchronization tasks and their solutions.
5. Allocation of shared resources - deadlocks, Coffman's conditions, strategies for deadlock solving.
6. Process/thread implementation. Thread scheduling.
7. Main memory management - virtual memory, memory allocation using dynamic partitioning.
8. Main memory management - virtual memory implemented using paging and segmentation.
9. Main memory management - page replacement algorithms.
10. Data storages - disks, RAID systems, connections to the host computer.
11. File systems - implementations of classical file systems.
12. File systems - implementation in the OS kernel, modern file systems and their advanced functions.
13. Tools for monitoring of OSs.

## TUTORIALS SYLLABUS
1. Programs with multiple threads.
2. Thread synchronisation I. (mutex, condition variables).
3. Thread synchronisation II. (semaphores, barriers).
4. Processes (fork(), exec(),...).
5. Deadlock, physical and virtual memory.
6. Page replacement algorithms.